--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -2676,6 +2676,7 @@
 	bool verbose_state_checks;
 	bool nuclear_pageflip;
 	int edp_vswing;
+	bool force_backlight_pmic;
 };
 extern struct i915_params i915 __read_mostly;
 
--- a/drivers/gpu/drm/i915/i915_params.c
+++ b/drivers/gpu/drm/i915/i915_params.c
@@ -55,6 +55,7 @@
 	.edp_vswing = 0,
 	.enable_guc_submission = false,
 	.guc_log_level = -1,
+	.force_backlight_pmic = false,
 };
 
 module_param_named(modeset, i915.modeset, int, 0400);
@@ -175,6 +176,10 @@
 	"Enable the MMIO debug code for the first N failures (default: off). "
 	"This may negatively affect performance.");
 
+module_param_named(force_backlight_pmic, i915.force_backlight_pmic, bool, 0600);
+MODULE_PARM_DESC(force_backlight_pmic,
+	"Force backlight adjusting through pmic (default: false).");
+
 module_param_named(verbose_state_checks, i915.verbose_state_checks, bool, 0600);
 MODULE_PARM_DESC(verbose_state_checks,
 	"Enable verbose logs (ie. WARN_ON()) in case of unexpected hw state conditions.");
--- a/drivers/gpu/drm/i915/intel_dsi.c
+++ b/drivers/gpu/drm/i915/intel_dsi.c
@@ -772,6 +772,8 @@
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct intel_crtc *intel_crtc = to_intel_crtc(encoder->crtc);
 	struct intel_dsi *intel_dsi = enc_to_intel_dsi(encoder);
+	struct intel_connector *intel_connector =
+		intel_dsi->attached_connector;
 	enum port port;
 	unsigned int bpp = intel_crtc->config->pipe_bpp;
 	unsigned int lane_count = intel_dsi->lane_count;
@@ -804,6 +806,8 @@
 			    intel_dsi->burst_mode_ratio);
 	hbp = txbyteclkhs(hbp, bpp, lane_count, intel_dsi->burst_mode_ratio);
 
+	intel_panel_disable_backlight(intel_connector);
+
 	for_each_dsi_port(port, intel_dsi->ports) {
 		if (IS_BROXTON(dev)) {
 			/*
@@ -1069,6 +1073,7 @@
 
 	DRM_DEBUG_KMS("\n");
 	intel_panel_fini(&intel_connector->panel);
+	intel_panel_destroy_backlight(connector);
 	drm_connector_cleanup(connector);
 	kfree(connector);
 }
--- a/drivers/gpu/drm/i915/intel_panel.c
+++ b/drivers/gpu/drm/i915/intel_panel.c
@@ -33,10 +33,17 @@
 #include <linux/kernel.h>
 #include <linux/moduleparam.h>
 #include <linux/pwm.h>
+#include <linux/i2c.h>
 #include "intel_drv.h"
 
 #define CRC_PMIC_PWM_PERIOD_NS	21333
 
+static int intel_soc_pmic_rw_init(void);
+static void intel_soc_pmic_rw_lock(void);
+static void intel_soc_pmic_rw_unlock(void);
+static int intel_soc_pmic_readb(int reg);
+static int intel_soc_pmic_writeb(int reg, u8 val);
+
 void
 intel_fixed_panel_mode(const struct drm_display_mode *fixed_mode,
 		       struct drm_display_mode *adjusted_mode)
@@ -551,6 +558,11 @@
 	return DIV_ROUND_UP(duty_ns * 100, CRC_PMIC_PWM_PERIOD_NS);
 }
 
+static u32 vlv_pmic_get_backlight(struct intel_connector *connector)
+{
+	return intel_soc_pmic_readb(0x4E);
+}
+
 static u32 intel_panel_get_backlight(struct intel_connector *connector)
 {
 	struct drm_device *dev = connector->base.dev;
@@ -648,6 +660,11 @@
 	pwm_config(panel->backlight.pwm, duty_ns, CRC_PMIC_PWM_PERIOD_NS);
 }
 
+static void vlv_pmic_set_backlight(struct intel_connector *connector, u32 level)
+{
+	intel_soc_pmic_writeb(0x4E, level);
+}
+
 static void
 intel_panel_actually_set_backlight(struct intel_connector *connector, u32 level)
 {
@@ -828,6 +845,16 @@
 	pwm_disable(panel->backlight.pwm);
 }
 
+static void vlv_pmic_disable_backlight(struct intel_connector *connector)
+{
+	intel_panel_actually_set_backlight(connector, 0);
+
+	intel_soc_pmic_rw_lock();
+	intel_soc_pmic_writeb(0x51, 0x00);
+	intel_soc_pmic_writeb(0x4B, 0x7F);
+	intel_soc_pmic_rw_unlock();
+}
+
 void intel_panel_disable_backlight(struct intel_connector *connector)
 {
 	struct drm_device *dev = connector->base.dev;
@@ -1100,6 +1127,19 @@
 	intel_panel_actually_set_backlight(connector, panel->backlight.level);
 }
 
+static void vlv_pmic_enable_backlight(struct intel_connector *connector)
+{
+	struct intel_panel *panel = &connector->panel;
+
+	intel_soc_pmic_rw_lock();
+	intel_soc_pmic_writeb(0x4B, 0xFF);
+	intel_soc_pmic_writeb(0x4E, 0xFF);
+	intel_soc_pmic_writeb(0x51, 0x01);
+	intel_soc_pmic_rw_unlock();
+
+	intel_panel_actually_set_backlight(connector, panel->backlight.level);
+}
+
 void intel_panel_enable_backlight(struct intel_connector *connector)
 {
 	struct drm_device *dev = connector->base.dev;
@@ -1681,6 +1721,21 @@
 	return 0;
 }
 
+static int vlv_pmic_setup_backlight(struct intel_connector *connector,
+				    enum pipe unused)
+{
+	struct intel_panel *panel = &connector->panel;
+
+	printk("vlv_pmic_setup_backlight\n");
+	panel->backlight.present = 1;
+	panel->backlight.min = 0x00;
+	panel->backlight.max = 0xFF;
+	panel->backlight.level = 0x5A;
+	panel->backlight.enabled = 1;
+
+	return 0;
+}
+
 int intel_panel_setup_backlight(struct drm_connector *connector, enum pipe pipe)
 {
 	struct drm_device *dev = connector->dev;
@@ -1689,6 +1744,8 @@
 	struct intel_panel *panel = &intel_connector->panel;
 	int ret;
 
+	intel_backlight_device_register(intel_connector);
+
 	if (!dev_priv->vbt.backlight.present) {
 		if (dev_priv->quirks & QUIRK_BACKLIGHT_PRESENT) {
 			DRM_DEBUG_KMS("no backlight present per VBT, but present per quirk\n");
@@ -1768,6 +1825,20 @@
 		panel->backlight.get = pch_get_backlight;
 		panel->backlight.hz_to_pwm = pch_hz_to_pwm;
 	} else if (IS_VALLEYVIEW(dev)) {
+		int s = intel_soc_pmic_rw_init();
+		if (s >= 0 && dev_priv->vbt.has_mipi) {
+			panel->backlight.setup = vlv_pmic_setup_backlight;
+			panel->backlight.enable = vlv_pmic_enable_backlight;
+			panel->backlight.disable = vlv_pmic_disable_backlight;
+			panel->backlight.set = vlv_pmic_set_backlight;
+			panel->backlight.get = vlv_pmic_get_backlight;
+		} else  if (s >= 0 && i915.force_backlight_pmic) {
+			panel->backlight.setup = vlv_pmic_setup_backlight;
+			panel->backlight.enable = vlv_pmic_enable_backlight;
+			panel->backlight.disable = vlv_pmic_disable_backlight;
+			panel->backlight.set = vlv_pmic_set_backlight;
+			panel->backlight.get = vlv_pmic_get_backlight;
+		} else
 		if (dev_priv->vbt.has_mipi) {
 			panel->backlight.setup = pwm_setup_backlight;
 			panel->backlight.enable = pwm_enable_backlight;
@@ -1839,3 +1910,55 @@
 	list_for_each_entry(connector, &dev->mode_config.connector_list, base.head)
 		intel_backlight_device_unregister(connector);
 }
+
+static struct i2c_client *intel_soc_pmic_i2c;
+
+static int intel_soc_pmic_rw_init(void)
+{
+	struct device *dev;
+
+	printk("intel_soc_pmic check on i915\n");
+	dev = bus_find_device_by_name(&i2c_bus_type, NULL, "i2c-INT33FD:00");
+	if (!dev)
+		return -1;
+	intel_soc_pmic_i2c = i2c_verify_client(dev);
+	
+	if (!intel_soc_pmic_i2c)
+		return -1;
+	printk("   found, use it\n");
+	return 0;
+}
+
+static void intel_soc_pmic_rw_lock(void) {}
+
+static void intel_soc_pmic_rw_unlock(void) {}
+
+static int intel_soc_pmic_readb(int reg)
+{
+	int s;
+	char buf[1];
+
+	if (!intel_soc_pmic_i2c) return -1;
+
+	/* send reg no */
+	buf[0] = reg;
+	s = i2c_master_send(intel_soc_pmic_i2c, buf, 1);
+	if (s < 0) return s;
+
+	/* recv data */
+	s = i2c_master_recv(intel_soc_pmic_i2c, buf, 1);
+	if (s < 0) return s;
+
+	return buf[0] & 0xff;
+}
+
+static int intel_soc_pmic_writeb(int reg, u8 val)
+{
+	char buf[2];
+
+	if (!intel_soc_pmic_i2c) return -1;
+
+	buf[0] = reg;
+	buf[1] = val;
+	return i2c_master_send(intel_soc_pmic_i2c, buf, 2);
+}
